// ============================
// GAME LOGIC
// ============================

function loadLevels() {
  fetch('levels.json')
    .then(function(response) {
      if (response.ok) {
        return response.json();
      } else {
        console.error('Could not load levels.json');
        return [];
      }
    })
    .then(function(data) {
      levels = data;
      // Start level after loading
      if (!isEditor && levels.length > 0) {
        startLevel(currentLevelIndex);
      }
    })
    .catch(function(e) {
      console.error('Error loading levels.json:', e);
    });
}

function startLevel(index) {
  // Update undo count display
  setTimeout(() => {
    const undoCountSpan = document.getElementById("undo-count");
    if (undoCountSpan) undoCountSpan.textContent = undoCount;
  }, 0);
  undoCount = 10;
  undoStack = [];
  const undoBtn = document.getElementById("undo-btn");
  if (undoBtn) {
    undoBtn.disabled = false;
    undoBtn.classList.remove("disabled");
  }
  currentLevelIndex = index;
  gameState.placedWords = [];
  renderGame._connectionsDrawn = false;
  renderGame(true);
  document.getElementById("success-screen").classList.add("hidden");
  
  // Initialize mobile selection to first unfilled slot
  if (gameState.isMobile) {
    selectSlot(getNextUnfilledSlot());
  }
}

function renderGame(force = false) {
  const level = levels[currentLevelIndex];
  if (!level) {
    console.error('No level data at index', currentLevelIndex);
    return;
  }
  renderSlots(level, force);
  renderBank(level);
  updateHints();
  // Draw connections only once after slots are rendered
  if (!renderGame._connectionsDrawn && !isEditorMode()) {
    renderConnections(level);
    renderGame._connectionsDrawn = true;
  }
}

function updateHints() {
  const level = levels[currentLevelIndex];
  // Clear all hints first (but not filled cells)
  for (let slotIndex = 0; slotIndex < level.slots.length; slotIndex++) {
    const slotDiv = document.querySelector(`[data-slot-index="${slotIndex}"]`);
    if (!slotDiv) continue;
    for (let i = 0; i < slotDiv.children.length; i++) {
      const cell = slotDiv.children[i];
      if (!cell.classList.contains("filled")) {
        cell.classList.remove("hint");
        cell.textContent = "";
      }
    }
  }
  // Now apply hints only to relevant cells
  level.connections.forEach(conn => {
    const [from, to] = conn.split("-");
    const fromPos = parseCellPosition(from);
    const toPos = parseCellPosition(to);
    const fromPlaced = gameState.placedWords.find(pw => pw.slotIndex === fromPos.slotIndex);
    const toPlaced = gameState.placedWords.find(pw => pw.slotIndex === toPos.slotIndex);
    // Show hint if one side is filled and other is empty
    if (fromPlaced && !toPlaced) {
      const requiredLetter = fromPlaced.word[fromPos.cellIndex];
      showHint(toPos.slotIndex, toPos.cellIndex, requiredLetter);
    } else if (toPlaced && !fromPlaced) {
      const requiredLetter = toPlaced.word[toPos.cellIndex];
      showHint(fromPos.slotIndex, fromPos.cellIndex, requiredLetter);
    }
  });
}

function showHint(slotIndex, cellIndex, letter) {
  const slot = document.querySelector(`[data-slot-index="${slotIndex}"]`);
  if (!slot) return;
  
  const cell = slot.querySelector(`[data-cell-index="${cellIndex}"]`);
  if (cell && !cell.classList.contains("filled")) {
    cell.textContent = letter;
    cell.classList.add("hint");
  }
}

function checkConstraints(word, slotIndex) {
  const level = levels[currentLevelIndex];
  const slotLength = level.slots[slotIndex].length;
  
  // Check word length
  if (word.length !== slotLength) {
    return { valid: false, reason: 'length' };
  }
  // Check connection constraints and hint mismatches
  for (const conn of level.connections) {
    const [from, to] = conn.split("-");
    const fromPos = parseCellPosition(from);
    const toPos = parseCellPosition(to);
    // If placing in fromPos slot, check against toPos slot
    if (fromPos.slotIndex === slotIndex) {
      const toPlaced = gameState.placedWords.find(pw => pw.slotIndex === toPos.slotIndex);
      if (toPlaced) {
        if (word[fromPos.cellIndex] !== toPlaced.word[toPos.cellIndex]) {
          return { valid: false, reason: 'hint', cellIndex: fromPos.cellIndex };
        }
      }
    }
    // If placing in toPos slot, check against fromPos slot
    if (toPos.slotIndex === slotIndex) {
      const fromPlaced = gameState.placedWords.find(pw => pw.slotIndex === fromPos.slotIndex);
      if (fromPlaced) {
        if (word[toPos.cellIndex] !== fromPlaced.word[fromPos.cellIndex]) {
          return { valid: false, reason: 'hint', cellIndex: toPos.cellIndex };
        }
      }
    }
  }
  return { valid: true };
}

function placeWord(word, slotIndex, bankIndex) {
  // Push to undo stack
  if (undoCount > 0) {
    undoStack.push({ word, slotIndex, bankIndex });
    if (undoStack.length > 10) undoStack.shift();
  }
  // Remove if already placed in this slot
  gameState.placedWords = gameState.placedWords.filter(pw => pw.slotIndex !== slotIndex);
  
  // Add new placement
  gameState.placedWords.push({ word, slotIndex, bankIndex });
  
  renderGame();
  checkLevelComplete();
}

function removeWordFromSlot(slotIndex) {
  gameState.placedWords = gameState.placedWords.filter(pw => pw.slotIndex !== slotIndex);
  renderGame();
}

function checkLevelComplete() {
  const level = levels[currentLevelIndex];
  if (gameState.placedWords.length !== level.slots.length) return;
  
  // Check all connections are satisfied
  for (const conn of level.connections) {
    const [from, to] = conn.split("-");
    const fromPos = parseCellPosition(from);
    const toPos = parseCellPosition(to);
    
    const fromPlaced = gameState.placedWords.find(pw => pw.slotIndex === fromPos.slotIndex);
    const toPlaced = gameState.placedWords.find(pw => pw.slotIndex === toPos.slotIndex);
    
    if (!fromPlaced || !toPlaced) return;
    if (fromPlaced.word[fromPos.cellIndex] !== toPlaced.word[toPos.cellIndex]) return;
  }
  
  // Level complete!
  document.getElementById("success-screen").classList.remove("hidden");
}

// ============================
// TUTORIAL SYSTEM
// ============================

function showTutorial() {
  const tutorialOverlay = document.getElementById("tutorial-overlay");
  const tutorialTitle = document.getElementById("tutorial-title");
  const tutorialText = document.getElementById("tutorial-text");
  const tutorialBtn = document.getElementById("tutorial-got-it-btn");
  const tutorialPointer = document.getElementById("tutorial-pointer");
  
  if (!tutorialOverlay) return;
  
  let tutorialStep = 0;
  
  function startInteractiveTutorial() {
    // Hide the initial content, show pointer
    tutorialTitle.style.display = "none";
    tutorialText.style.display = "none";
    tutorialBtn.style.display = "none";
    tutorialPointer.classList.remove("hidden");
    tutorialOverlay.classList.add("interactive");
    
    if (gameState.isMobile) {
      showMobileTutorial();
    } else {
      showDesktopTutorial();
    }
  }
  
  function showDesktopTutorial() {
    // Get the word in the bank (first word)
    const bankWord = document.querySelector('.bank-word');
    const slot = document.querySelector('.word-slot');
    
    if (!bankWord || !slot) {
      endTutorial();
      return;
    }
    
    // Add highlight to word and slot
    bankWord.classList.add('tutorial-highlight');
    slot.classList.add('tutorial-highlight');
    
    // Position pointer at the word
    const wordRect = bankWord.getBoundingClientRect();
    const containerRect = document.getElementById('game-container').getBoundingClientRect();
    
    tutorialPointer.style.left = (wordRect.left - containerRect.left + wordRect.width / 2 - 30) + 'px';
    tutorialPointer.style.top = (wordRect.top - containerRect.top + wordRect.height / 2 - 30) + 'px';
    tutorialPointer.classList.add('drag-animation');
    
    // Show instruction text overlay
    showInstructionText("Drag the word up to the slot");
    
    // Listen for successful placement
    const checkPlacement = setInterval(() => {
      if (gameState.placedWords.length > 0) {
        clearInterval(checkPlacement);
        endTutorial();
      }
    }, 100);
  }
  
  function showMobileTutorial() {
    if (tutorialStep === 0) {
      // Step 1: Tap the slot
      const slot = document.querySelector('.word-slot');
      if (!slot) {
        endTutorial();
        return;
      }
      
      slot.classList.add('tutorial-highlight');
      
      const slotRect = slot.getBoundingClientRect();
      const containerRect = document.getElementById('game-container').getBoundingClientRect();
      
      tutorialPointer.style.left = (slotRect.left - containerRect.left + slotRect.width / 2 - 25) + 'px';
      tutorialPointer.style.top = (slotRect.top - containerRect.top + slotRect.height / 2 - 25) + 'px';
      tutorialPointer.classList.add('tap-pulse');
      
      showInstructionText("Step 1: Tap the slot to select it");
      
      // Wait for slot selection
      const checkSelection = setInterval(() => {
        if (gameState.selectedSlotIndex !== null && gameState.selectedSlotIndex !== undefined) {
          clearInterval(checkSelection);
          slot.classList.remove('tutorial-highlight');
          tutorialStep = 1;
          setTimeout(() => showMobileTutorial(), 500);
        }
      }, 100);
      
    } else if (tutorialStep === 1) {
      // Step 2: Tap the word
      const bankWord = document.querySelector('.bank-word');
      if (!bankWord) {
        endTutorial();
        return;
      }
      
      bankWord.classList.add('tutorial-highlight');
      
      const wordRect = bankWord.getBoundingClientRect();
      const containerRect = document.getElementById('game-container').getBoundingClientRect();
      
      tutorialPointer.classList.remove('tap-pulse');
      tutorialPointer.style.left = (wordRect.left - containerRect.left + wordRect.width / 2 - 25) + 'px';
      tutorialPointer.style.top = (wordRect.top - containerRect.top + wordRect.height / 2 - 25) + 'px';
      tutorialPointer.classList.add('tap-word');
      
      showInstructionText("Step 2: Tap the word to place it");
      
      // Wait for word placement
      const checkPlacement = setInterval(() => {
        if (gameState.placedWords.length > 0) {
          clearInterval(checkPlacement);
          endTutorial();
        }
      }, 100);
    }
  }
  
  function showInstructionText(text) {
    // Create or update floating instruction
    let instruction = document.getElementById('tutorial-instruction');
    if (!instruction) {
      instruction = document.createElement('div');
      instruction.id = 'tutorial-instruction';
      instruction.style.cssText = `
        position: absolute;
        top: 20%;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        padding: 20px 30px;
        border-radius: 12px;
        font-size: 20px;
        font-weight: bold;
        color: #333;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        z-index: 3;
        text-align: center;
        pointer-events: none;
      `;
      tutorialOverlay.appendChild(instruction);
    }
    instruction.textContent = text;
  }
  
  function endTutorial() {
    // Remove highlights
    document.querySelectorAll('.tutorial-highlight').forEach(el => {
      el.classList.remove('tutorial-highlight');
    });
    
    // Remove instruction text
    const instruction = document.getElementById('tutorial-instruction');
    if (instruction) instruction.remove();
    
    // Hide pointer
    tutorialPointer.classList.add('hidden');
    tutorialPointer.classList.remove('drag-animation', 'tap-pulse', 'tap-word');
    
    // Show completion message
    tutorialTitle.style.display = "block";
    tutorialText.style.display = "block";
    tutorialBtn.style.display = "block";
    
    tutorialTitle.textContent = "Great job! ðŸŽ‰";
    tutorialText.textContent = "You've learned the basics! Continue playing to master the game.";
    
    tutorialBtn.onclick = function() {
      tutorialOverlay.classList.add("hidden");
      tutorialOverlay.classList.remove("interactive");
    };
  }
  
  // Set initial tutorial content
  tutorialTitle.textContent = "Welcome to Word Web! ï¿½";
  tutorialText.innerHTML = "Let's learn how to play!<br><br>Click the button below to start the interactive tutorial.";
  
  // Show tutorial
  tutorialOverlay.classList.remove("hidden");
  
  // Handle start button click
  tutorialBtn.textContent = "Start Tutorial";
  tutorialBtn.onclick = function() {
    startInteractiveTutorial();
  };
}
